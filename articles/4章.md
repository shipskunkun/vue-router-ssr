## 4-4 

同一个页面多个 router-view 怎么操作？
给router-view 命令

这时候，

```
<router-view class="view one"></router-view>
<router-view class="view two" name="a"></router-view>
<router-view class="view three" name="b"></router-view>

routes: [
    {
      path: '/',
      components: {
        default: Foo,
        a: Bar,
        b: Baz
      }
    }
  ]
```


路由守卫

```
const Foo = {
  template: `...`,
  beforeRouteEnter (to, from, next) {
    // 在渲染该组件的对应路由被 confirm 前调用
    // 不！能！获取组件实例 `this`
    // 因为当守卫执行前，组件实例还没被创建
    
    console.log(this); //undefined
    next();
    console.log(this); //undefind
  },
  beforeRouteUpdate (to, from, next) {
    // 在当前路由改变，但是该组件被复用时调用
    // 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，
    // 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。
    // 可以访问组件实例 `this`
    
    
    
    自己试了一下，直接在浏览器中修改路由，监测不到，只有在router中配置的+满足条件的，才可以
    http://localhost:8080/a/123/zhangsan
    跳转到
    http://localhost:8080/a/123/lisi    //可以检测到
    
    http://localhost:8080/a/123/zhangsan
    跳转到
    http://localhost:8080/a/123/zhangsan/c    //也可以检测到
    
    
  },
  beforeRouteLeave (to, from, next) {
    // 导航离开该组件的对应路由时调用
    // 可以访问组件实例 `this`
  }
}

```



## 杂

```
// redirect的使用，怎么用的，首页默认跳转到某个路由
{
    path: '/',
    redirect: '/a',
}, {
    path: '/a',
    name: 'A',
    component: A
}


// to 的几种写法：
path: '/a/:id',
name: 'A'

<router-link to="a/123">点击跳到A页面</router-link>
<router-link :to="{name:'A', params: {id: 123}}">点击跳到A页面</router-link>
 <router-link :to="{name:'A', params:{id: 123}, query:{name: 456}}">点击跳到A页面</router-link>
router.push({ path: `/user/${userId}` }) // -> /user/123
 
path: '/b',
<router-link :to="{name: 'B'}">点击跳到B页面</router-link>



```




## 4-1、4-2、4-3

vue默认hash路由，是不会被搜索引擎解析，不利于SEO

 
 怎么配置history？  
 mode: 'history'  
 base: 基路径
 
 ```
 linkActiveClass  
 linkExtractActiveClass   //当前路径和 router-link 中路径完全相同时候
 ```
  
  
  使用history mode注意点：
  需要配置 webpack的 devServer
  
  ```
  //base路径和 output中的 publicPath 一致
  
  historyApiFallback: {
  	index: '/base/index.html'
  }
  
  output: {
    path: config.build.assetsRoot,
    filename: '[name].js',
    publicPath: process.env.NODE_ENV === 'production'
      ? config.build.assetsPublicPath
      : config.dev.assetsPublicPath
  }

  ```
  
  
  路由要name有啥用：  
  可以代替 path进行路由跳转 
  
  ```
  // 当传对象时候，不是字符串，所以是 :to
  <router-link :to="{name: 'app'}">
  <router-link to="/app">
  
  //路由对象,和路由没啥关系的信息，放在meta中
  //在 route 对象的meta属性中可以拿到
  mata: {
  	title: 'this ia app',
  }
  
  //父路由组件中需要添加 <router-view>
  // path 是相对父组件路径，而且和父组件在同一页面
  children: [	
 	{
 		path: 'test',
 		component: Login
 	}  
  ]
  
  
  props: true  //params中的参数给 children组件
  可以传多个值吗？可以
  
  path: '/a/:id/:name',
  props: true,
  name: 'A',
  component: A,
	
  //组件A里面接受
  props: ['id', 'name'],
  
  ```
  
  
  query: ?开始到结束，后面的东西
  
  
  
  
  
  
  
  
  
  